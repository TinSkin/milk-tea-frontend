// File: src/store/cartStore.js
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { cartAPI } from "../api/cartAPI";

const isDev = import.meta.env.MODE === "development";

const useCartStore = create(
  persist(
    (set, get) => ({
      // State - TH√äM storeCarts ƒë·ªÉ l∆∞u multiple carts
      items: [],
      selectedItems: [],
      isAuthenticated: false,
      currentStoreId: null,
      isLoading: false,
      storeCarts: {},

      // Actions
      setSelectedItems: (selected) => set({ selectedItems: selected }),
      getSelectedItems: () => get().selectedItems,

      // Set authentication status
      setAuthStatus: (status) => set({ isAuthenticated: status }),

      // Helper function: log only in dev
      _log: (...args) => {
        if (isDev) console.log(...args);
      },

      // ‚úÖ S·ª¨A: Set current store + t·ª± ƒë·ªông switch cart
      setCurrentStore: async (storeId) => {
        const { currentStoreId, storeCarts, items: currentItems } = get();

        if (currentStoreId === storeId) return;

        get()._log(
          `üè™ [Cart] Switching store: ${currentStoreId} ‚Üí ${storeId}`,
          {
            currentItems: currentItems.length,
          }
        );

        // 1. L∆∞u cart hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn
        if (currentStoreId && currentItems.length > 0) {
          set({
            storeCarts: {
              ...storeCarts,
              [currentStoreId]: {
                items: currentItems,
                lastUpdated: Date.now(),
              },
            },
          });
          get()._log(
            `üíæ [Cart] Saved current cart for store ${currentStoreId}:`,
            currentItems.length,
            "items"
          );
        }

        // 2. Chuy·ªÉn sang store m·ªõi - ∆ØU TI√äN local storage, n·∫øu r·ªóng th√¨ d√πng current items
        let newCartItems = storeCarts[storeId]?.items || [];

        // ‚úÖ QUAN TR·ªåNG: N·∫øu ƒëang c√≥ items v√† store m·ªõi ch∆∞a c√≥ cart, GI·ªÆ L·∫†I items hi·ªán t·∫°i
        if (currentItems.length > 0 && newCartItems.length === 0) {
          newCartItems = currentItems;
          get()._log("üîÑ [Cart] Keeping current items for new store");
        }

        // Set currentStoreId and tentative items, but avoid overwriting later loads if a backend load is in progress
        set({
          currentStoreId: storeId,
          items: newCartItems,
          isLoading: false,
        });

        get()._log(
          `‚úÖ [Cart] Switched to store ${storeId}, items:`,
          newCartItems.length
        );

        // 3. N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, load t·ª´ backend SAU KHI ƒë√£ set items
        if (get().isAuthenticated) {
          get()._log("üîÑ [Cart] Loading backend cart after store switch...");
          // Small debounce to ensure any other state updates settle
          setTimeout(async () => {
            try {
              await get().loadCartFromBackend(storeId);
            } catch (error) {
              console.error(
                "‚ùå [Cart] Error loading backend cart after switch:",
                error
              );
            }
          }, 500);
        }
      },

      // ‚úÖ TH√äM: Switch store v·ªõi logic ƒë·∫ßy ƒë·ªß
      switchStore: async (newStoreId) => {
        await get().setCurrentStore(newStoreId);
      },

      // Helper function
      _mapToppingsForCompare: (arr) =>
        JSON.stringify(
          (arr || [])
            .map((t) => ({
              _id: t._id,
              name: t.name,
              extraPrice: t.extraPrice || 0,
            }))
            // sort to ensure deterministic string
            .sort((a, b) => (a._id || "").toString().localeCompare(b._id || ""))
        ),

      // Helper: Compare toppings
      _compareToppings: (a, b) => {
        const normalize = (arr) =>
          (arr || [])
            .map((t) =>
              t.toppingId?._id
                ? t.toppingId._id.toString()
                : t._id?.toString() || t.toString()
            )
            .sort()
            .join(",");
        return normalize(a) === normalize(b);
      },

      // Helper: Transform backend items to local format - S·ª¨A HO√ÄN TO√ÄN
      _transformBackendToLocal: (backendItems) => {
        if (!backendItems || !Array.isArray(backendItems)) return [];

        get()._log("üîÑ [Transform] Backend items:", backendItems);

        return backendItems.map((item) => {
          const backendToppings = item.toppings || [];

          const transformedToppings = backendToppings.map((t) => {
            const toppingData = t.toppingId || t;

            return {
              _id: toppingData._id || t._id,
              name: toppingData.name || t.name || "Topping",
              extraPrice: toppingData.extraPrice || t.extraPrice || 0,
            };
          });

          const sizePrice = item.sizeOptionPrice || 0;
          const toppingsPrice = transformedToppings.reduce(
            (sum, t) => sum + (t.extraPrice || 0),
            0
          );

          // price here is unit price (size + toppings) ‚Äî preserve previous behaviour where item's displayed price = (size+toppings)*quantity
          const unitPrice = sizePrice + toppingsPrice;
          const totalPrice = unitPrice * (item.quantity || 1);

          return {
            id: item.productId?._id || item.productId,
            _id: item._id,
            name: item.productId?.name || "S·∫£n ph·∫©m",
            images: item.productId?.images || [],
            // keep both unit and total-ish compatibility: use unitPrice as price and quantity multiply elsewhere
            price: unitPrice,
            quantity: item.quantity || 1,
            sizeOption: item.sizeOption || "M",
            sizeOptionPrice: item.sizeOptionPrice || sizePrice || 0,
            sugarLevel: item.sugarLevel || "100%",
            iceOption: item.iceOption || "Chung",
            toppings: transformedToppings,
            availableToppings: item.productId?.availableToppings || [],
            sizeOptions: item.productId?.sizeOptions || [],
            // legacy compatibility: include computedTotal in case UI expects it
            _computedTotal: totalPrice,
          };
        });
      },

      // File: store/cartStore.js
      // ‚úÖ S·ª¨A: Sync cart KH√îNG clear cart c≈©
      syncCartToBackend: async () => {
        const { items, currentStoreId, isAuthenticated } = get();

        get()._log("üîÑ [SYNC] Starting SMART SYNC", {
          localItems: items.length,
          currentStoreId,
          isAuthenticated,
        });

        if (!isAuthenticated || !currentStoreId) {
          get()._log("‚ùå [SYNC] Skipped - not authenticated or no storeId");
          return;
        }

        // N·∫øu local cart r·ªóng, ch·ªâ load t·ª´ backend (KH√îNG CLEAR)
        if (items.length === 0) {
          get()._log("üîÑ [SYNC] Local cart empty, loading from backend only");
          await get().loadCartFromBackend(currentStoreId);
          return;
        }

        try {
          set({ isLoading: true });

          // 1. L·∫•y gi·ªè h√†ng hi·ªán t·∫°i t·ª´ backend
          get()._log("üì¶ [SYNC] Getting existing backend cart...");
          let backendCart;
          try {
            const response = await cartAPI.getCart(currentStoreId);
            // cartAPI.getCart returns already-parsed object (see your api impl)
            backendCart = response.data || response || { items: [] };
            get()._log(
              "üì¶ [SYNC] Backend cart loaded:",
              backendCart.items?.length || 0,
              "items"
            );
          } catch (error) {
            get()._log("üì¶ [SYNC] No backend cart found, will create new one");
            backendCart = { items: [] };
          }

          // 2. SMART MERGE: Th√™m local items v√†o backend (KH√îNG CLEAR)
          get()._log("üîÑ [SYNC] Merging local items to backend...");

          // Use Promise.all to speed up multiple add requests
          await Promise.all(
            items.map(async (localItem) => {
              get()._log(
                "üîç [SYNC] Processing local item:",
                localItem.name,
                "x",
                localItem.quantity
              );

              try {
                // Transform toppings to backend format expected by API
                const backendToppings = (localItem.toppings || []).map((t) => ({
                  toppingId: t._id,
                }));

                // Call addToCart API for each item
                await cartAPI.addToCart({
                  storeId: currentStoreId,
                  productId: localItem.id,
                  quantity: localItem.quantity,
                  sizeOption: localItem.sizeOption,
                  sugarLevel: localItem.sugarLevel,
                  iceOption: localItem.iceOption,
                  toppings: backendToppings,
                  specialNotes: localItem.specialNotes || "",
                });

                get()._log(
                  "‚úÖ [SYNC] Item merged successfully:",
                  localItem.name
                );
              } catch (error) {
                get()._log(
                  "‚ùå [SYNC] Failed to merge item:",
                  error?.message || error
                );
                // swallow individual item errors to continue merging others
              }
            })
          );

          get()._log("‚úÖ [SYNC] Merge process completed");

          // 3. Load l·∫°i gi·ªè h√†ng ƒë√£ merged t·ª´ backend
          get()._log("üîÑ [SYNC] Reloading final cart from backend...");
          await get().loadCartFromBackend(currentStoreId);

          get()._log("üéâ [SYNC] SMART MERGE completed!");
        } catch (error) {
          console.error("‚ùå [SYNC] syncCartToBackend error:", error);
        } finally {
          set({ isLoading: false });
        }
      },

      // ‚úÖ S·ª¨A: Load gi·ªè h√†ng t·ª´ backend
     // File: store/cartStore.js
// ‚úÖ S·ª¨A HO√ÄN TO√ÄN: Load cart t·ª´ backend - ∆ØU TI√äN LOCAL CART
loadCartFromBackend: async (storeId = null) => {
  const effectiveStoreId = storeId || get().currentStoreId;
  const { isAuthenticated, _transformBackendToLocal, items: currentLocalItems } = get();

  if (!isAuthenticated || !effectiveStoreId) {
    get()._log("‚ùå [LOAD] Cannot load - not authenticated or no storeId");
    return currentLocalItems; // Tr·∫£ v·ªÅ items hi·ªán t·∫°i
  }

  try {
    set({ isLoading: true });
    get()._log("üì• [LOAD] Loading cart from backend for store:", effectiveStoreId, {
      currentLocalItems: currentLocalItems.length
    });
    
    const response = await cartAPI.getCart(effectiveStoreId);
    const backendData = response.data || response || {};
    const backendItems = backendData.items || [];
    const transformedBackendItems = _transformBackendToLocal(backendItems);

    get()._log("üîÑ [LOAD] Backend vs Local:", {
      backendItems: transformedBackendItems.length,
      localItems: currentLocalItems.length
    });

    // ‚úÖ QUAN TR·ªåNG: QUY·∫æT ƒê·ªäNH ITEMS CU·ªêI C√ôNG
    let finalItems = currentLocalItems;

    // N·∫æU: Local c√≥ items V√Ä backend c≈©ng c√≥ items ‚Üí MERGE
    if (currentLocalItems.length > 0 && transformedBackendItems.length > 0) {
      get()._log("üîÄ [LOAD] Both local and backend have items - SMART MERGING");
      
      // T·∫°o map c·ªßa backend items ƒë·ªÉ merge
      const backendItemsMap = new Map();
      transformedBackendItems.forEach(item => {
        const key = `${item.id}__${item.sizeOption}__${get()._mapToppingsForCompare(item.toppings)}`;
        backendItemsMap.set(key, item);
      });

      // Merge logic: ∆Øu ti√™n local items, nh∆∞ng c·∫≠p nh·∫≠t t·ª´ backend n·∫øu c·∫ßn
      const mergedItems = currentLocalItems.map(localItem => {
        const key = `${localItem.id}__${localItem.sizeOption}__${get()._mapToppingsForCompare(localItem.toppings)}`;
        const backendItem = backendItemsMap.get(key);
        
        if (backendItem) {
          // Item t·ªìn t·∫°i ·ªü c·∫£ 2 b√™n ‚Üí gi·ªØ th√¥ng tin local nh∆∞ng c√≥ th·ªÉ c·∫≠p nh·∫≠t _id t·ª´ backend
          backendItemsMap.delete(key); // ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω
          return {
            ...localItem,
            _id: backendItem._id, // Gi·ªØ _id t·ª´ backend ƒë·ªÉ c√°c thao t√°c sau
          };
        }
        return localItem;
      });

      // Th√™m c√°c items ch·ªâ c√≥ trong backend (n·∫øu c√≥)
      const remainingBackendItems = Array.from(backendItemsMap.values());
      if (remainingBackendItems.length > 0) {
        get()._log("‚ûï [LOAD] Adding", remainingBackendItems.length, "items from backend");
        mergedItems.push(...remainingBackendItems);
      }

      finalItems = mergedItems;
      
    } 
    // N·∫æU: Local tr·ªëng NH∆ØNG backend c√≥ items ‚Üí D√ôNG BACKEND
    else if (currentLocalItems.length === 0 && transformedBackendItems.length > 0) {
      get()._log("üì• [LOAD] Local empty, using backend items");
      finalItems = transformedBackendItems;
    }
    // N·∫æU: Local c√≥ items NH∆ØNG backend tr·ªëng ‚Üí GI·ªÆ LOCAL (kh√¥ng l√†m g√¨)
    else if (currentLocalItems.length > 0 && transformedBackendItems.length === 0) {
      get()._log("üíæ [LOAD] Backend empty, keeping local items");
      finalItems = currentLocalItems;
    }
    // N·∫æU: C·∫£ 2 ƒë·ªÅu tr·ªëng ‚Üí tr·ªëng
    else {
      get()._log("üì≠ [LOAD] Both local and backend are empty");
      finalItems = [];
    }

    // ‚úÖ C·∫¨P NH·∫¨T STATE
    const { storeCarts } = get();
    set({
      items: finalItems,
      storeCarts: {
        ...storeCarts,
        [effectiveStoreId]: {
          items: finalItems,
          lastUpdated: Date.now(),
        },
      },
      isLoading: false,
    });

    get()._log(`‚úÖ [LOAD] Final cart:`, finalItems.length, "items");
    return finalItems;

  } catch (error) {
    console.error("‚ùå [LOAD] Error loading cart:", error);
    set({ isLoading: false });
    // Tr·∫£ v·ªÅ items hi·ªán t·∫°i n·∫øu c√≥ l·ªói
    return currentLocalItems;
  }
},

      // ‚úÖ S·ª¨A: Add to cart - c·∫≠p nh·∫≠t c·∫£ storeCarts
      addToCart: async (product, quantity = 1) => {
        const {
          isAuthenticated,
          currentStoreId,
          _mapToppingsForCompare,
          loadCartFromBackend,
          storeCarts,
          _transformBackendToLocal,
        } = get();

        // ‚úÖ KI·ªÇM TRA: Ph·∫£i c√≥ storeId
        if (!currentStoreId) {
          console.error("‚ùå [Cart] No storeId available for addToCart");
          return { success: false, error: "NO_STORE_SELECTED" };
        }

        // T√¨m item tr√πng trong local
        const existingItemIndex = get().items.findIndex(
          (item) =>
            item.id === product._id &&
            item.sizeOption === (product.sizeOption || "M") &&
            item.sugarLevel === (product.sugarLevel || "100%") &&
            item.iceOption === (product.iceOption || "Chung") &&
            _mapToppingsForCompare(item.toppings) ===
              _mapToppingsForCompare(product.toppings)
        );

        const sizeOptionObj = product.sizeOptions?.find(
          (s) => s.size === (product.sizeOption || "M")
        );

        const rawAvailable =
          product.availableToppings ||
          product.allToppings ||
          product.toppings ||
          [];

        //Transform toppings ƒë·ªÉ g·ª≠i l√™n backend ƒê√öNG FORMAT
        const backendToppings = (product.toppings || []).map((t) => {
          // Backend mong ƒë·ª£i { toppingId: string } ho·∫∑c string
          return {
            toppingId: t._id || t, // Ch·ªâ g·ª≠i ID, kh√¥ng g·ª≠i c·∫£ object
          };
        });

        // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, g·ªçi API
        if (isAuthenticated && currentStoreId) {
          try {
            const response = await cartAPI.addToCart({
              storeId: currentStoreId,
              productId: product._id,
              quantity: quantity,
              sizeOption: product.sizeOption || "M",
              sugarLevel: product.sugarLevel || "100%",
              iceOption: product.iceOption || "Chung",
              toppings: backendToppings,
              specialNotes: "",
            });

            // N·∫øu backend tr·∫£ v·ªÅ cart/data th√¨ c·∫≠p nh·∫≠t local t·ª´ response (tr√°nh re-fetch n·∫∑ng)
            const respData = response.data || response || {};
            if (respData.data?.items) {
              const transformed = _transformBackendToLocal(respData.data.items);
              set({
                items: transformed,
                storeCarts: {
                  ...storeCarts,
                  [currentStoreId]: {
                    items: transformed,
                    lastUpdated: Date.now(),
                  },
                },
              });
            } else {
              // fallback: reload full cart for consistency
              await loadCartFromBackend(currentStoreId);
            }
            return;
          } catch (error) {
            console.error("‚ùå [Cart] Error adding to backend:", error);
            // Fallback to local below
          }
        }

        // Local handling (fallback ho·∫∑c ch∆∞a ƒëƒÉng nh·∫≠p)
        let newItems;
        if (existingItemIndex !== -1) {
          newItems = [...get().items];
          newItems[existingItemIndex].quantity += quantity;
        } else {
          const newItem = {
            id: product._id,
            name: product.name,
            images: product.images || [],
            price: product.price || 0,
            quantity: quantity,
            sizeOption:
              product.sizeOption || (product.sizeOptions?.[0]?.size ?? "M"),
            sizeOptionPrice: sizeOptionObj?.price || 0,
            sugarLevel: product.sugarLevel || "100%",
            iceOption: product.iceOption || "Chung",
            sizeOptions: product.sizeOptions || [],
            toppings: (product.toppings || []).map((t) => ({
              _id: t._id,
              name: t.name,
              extraPrice: t.extraPrice || 0,
            })),
            availableToppings: (rawAvailable || []).map((t) => ({
              _id: t._id,
              name: t.name,
              extraPrice: t.extraPrice || 0,
            })),
          };
          newItems = [...get().items, newItem];
        }

        // ‚úÖ C·∫¨P NH·∫¨T C·∫¢ storeCarts
        set({
          items: newItems,
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: newItems,
              lastUpdated: Date.now(),
            },
          },
        });
      },

      // ‚úÖ S·ª¨A: Remove from cart - c·∫≠p nh·∫≠t c·∫£ storeCarts
      removeFromCart: async (id, options = {}) => {
        const {
          isAuthenticated,
          currentStoreId,
          _mapToppingsForCompare,
          loadCartFromBackend,
          storeCarts,
        } = get();

        // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, x√≥a trong backend
        if (isAuthenticated && currentStoreId) {
          try {
            // T√¨m item trong local ƒë·ªÉ l·∫•y _id t·ª´ backend
            const localItem = get().items.find(
              (item) =>
                item.id === id &&
                item.sizeOption === (options.sizeOption || "M") &&
                item.sugarLevel === (options.sugarLevel || "100%") &&
                item.iceOption === (options.iceOption || "Chung") &&
                _mapToppingsForCompare(item.toppings) ===
                  _mapToppingsForCompare(options.toppings)
            );

            if (localItem && localItem._id) {
              await cartAPI.removeFromCart({
                storeId: currentStoreId,
                itemId: localItem._id,
              });
              await loadCartFromBackend(currentStoreId);
              return;
            }
          } catch (error) {
            console.error("‚ùå [Cart] Error removing from backend:", error);
            // Fallback to local
          }
        }

        // Local handling
        const updatedItems = get().items.filter(
          (item) =>
            !(
              item.id === id &&
              item.sizeOption === (options.sizeOption || "M") &&
              item.sugarLevel === (options.sugarLevel || "100%") &&
              item.iceOption === (options.iceOption || "Chung") &&
              _mapToppingsForCompare(item.toppings) ===
                _mapToppingsForCompare(options.toppings)
            )
        );

        // ‚úÖ C·∫¨P NH·∫¨T C·∫¢ storeCarts
        set({
          items: updatedItems,
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: updatedItems,
              lastUpdated: Date.now(),
            },
          },
        });
      },

      // ‚úÖ S·ª¨A: Update quantity - c·∫≠p nh·∫≠t c·∫£ storeCarts
      updateQuantity: async (id, quantity, options = {}) => {
        const {
          isAuthenticated,
          currentStoreId,
          _mapToppingsForCompare,
          loadCartFromBackend,
          storeCarts,
        } = get();

        // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, c·∫≠p nh·∫≠t backend
        if (isAuthenticated && currentStoreId) {
          try {
            const localItem = get().items.find(
              (item) =>
                item.id === id &&
                item.sizeOption === (options.sizeOption || "M") &&
                item.sugarLevel === (options.sugarLevel || "100%") &&
                item.iceOption === (options.iceOption || "Chung") &&
                _mapToppingsForCompare(item.toppings) ===
                  _mapToppingsForCompare(options.toppings)
            );

            if (localItem && localItem._id) {
              await cartAPI.updateQuantity({
                storeId: currentStoreId,
                itemId: localItem._id,
                quantity: quantity,
              });
              await loadCartFromBackend(currentStoreId);
              return;
            }
          } catch (error) {
            console.error(
              "‚ùå [Cart] Error updating quantity in backend:",
              error
            );
            // Fallback to local
          }
        }

        // Local handling
        const updatedItems = get().items.map((item) => {
          if (
            item.id === id &&
            item.sizeOption === (options.sizeOption || "M") &&
            item.sugarLevel === (options.sugarLevel || "100%") &&
            item.iceOption === (options.iceOption || "Chung") &&
            _mapToppingsForCompare(item.toppings) ===
              _mapToppingsForCompare(options.toppings)
          ) {
            return { ...item, quantity };
          }
          return item;
        });

        // ‚úÖ C·∫¨P NH·∫¨T C·∫¢ storeCarts
        set({
          items: updatedItems,
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: updatedItems,
              lastUpdated: Date.now(),
            },
          },
        });
      },

      // ‚úÖ S·ª¨A: Update cart item - c·∫≠p nh·∫≠t c·∫£ storeCarts
      updateCartItem: async (oldItem, updatedItem) => {
        const {
          isAuthenticated,
          currentStoreId,
          _mapToppingsForCompare,
          loadCartFromBackend,
          storeCarts,
        } = get();

        if (isAuthenticated && currentStoreId) {
          try {
            const backendToppings = (updatedItem.toppings || []).map((t) => ({
              toppingId: t._id, // Ch·ªâ g·ª≠i ID
            }));

            get()._log(
              "‚úèÔ∏è [Cart] Updating item with toppings:",
              backendToppings
            );
            await cartAPI.updateCartItem({
              storeId: currentStoreId,
              itemId: oldItem._id,
              newConfig: {
                toppings: backendToppings,
                specialNotes: updatedItem.specialNotes || "",
                sizeOption: updatedItem.sizeOption,
                sugarLevel: updatedItem.sugarLevel,
                iceOption: updatedItem.iceOption,
              },
            });
            await loadCartFromBackend(currentStoreId);
            return;
          } catch (error) {
            console.error("‚ùå [Cart] Error updating item in backend:", error);
          }
        }

        // Local implementation
        const updatedItems = get().items.map((item) => {
          if (
            item.id === oldItem.id &&
            item.sizeOption === oldItem.sizeOption &&
            item.sugarLevel === oldItem.sugarLevel &&
            item.iceOption === oldItem.iceOption &&
            _mapToppingsForCompare(item.toppings) ===
              _mapToppingsForCompare(oldItem.toppings)
          ) {
            const newSizePrice = updatedItem.sizeOptionPrice || 0;
            const toppingTotal = (updatedItem.toppings || []).reduce(
              (s, t) => s + (t.extraPrice || 0),
              0
            );

            return {
              ...item,
              ...updatedItem,
              availableToppings:
                item.availableToppings || updatedItem.availableToppings || [],
              sizeOptions: item.sizeOptions || updatedItem.sizeOptions || [],
              price: newSizePrice + toppingTotal,
            };
          }
          return item;
        });

        // ‚úÖ C·∫¨P NH·∫¨T C·∫¢ storeCarts
        set({
          items: updatedItems,
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: updatedItems,
              lastUpdated: Date.now(),
            },
          },
        });
      },

      // ‚úÖ S·ª¨A: Clear cart - ch·ªâ clear store hi·ªán t·∫°i
      clearCart: async () => {
        const { isAuthenticated, currentStoreId, storeCarts } = get();

        if (isAuthenticated && currentStoreId) {
          try {
            get()._log("üóëÔ∏è [CLEAR] Attempting to clear backend cart...");

            try {
              const existingCart = await cartAPI.getCart(currentStoreId);
              const backendItems =
                existingCart?.data?.items || existingCart?.items || [];
              if (backendItems && backendItems.length > 0) {
                await cartAPI.clearCart(currentStoreId);
                get()._log("‚úÖ [CLEAR] Backend cart cleared successfully");
                // reload to keep in sync
                await get().loadCartFromBackend(currentStoreId);
              } else {
                get()._log(
                  "‚ÑπÔ∏è [CLEAR] No backend cart to clear (already empty)"
                );
              }
            } catch (error) {
              get()._log("‚ÑπÔ∏è [CLEAR] No backend cart found to clear");
            }
          } catch (error) {
            console.error(
              "‚ùå [CLEAR] Error clearing backend cart:",
              error.message
            );
          }
        }

        // ‚úÖ CLEAR CH·ªà store hi·ªán t·∫°i
        set({
          items: [],
          selectedItems: [],
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: [],
              lastUpdated: Date.now(),
            },
          },
        });
        get()._log("‚úÖ [CLEAR] Local cart cleared for store:", currentStoreId);
      },

      // ‚úÖ TH√äM: Helper functions cho multi-store
      getCartByStore: (storeId) => {
        return get().storeCarts[storeId]?.items || [];
      },

      getStoreCartInfo: (storeId) => {
        const cart = get().storeCarts[storeId];
        if (!cart) return { itemCount: 0, total: 0 };

        const itemCount = cart.items.reduce(
          (sum, item) => sum + (item.quantity || 0),
          0
        );
        const total = cart.items.reduce(
          (total, item) => total + (item.price || 0) * (item.quantity || 1),
          0
        );

        return { itemCount, total };
      },

      // C√°c h√†m helper kh√°c
      getCurrentItems: () => get().items,
      getTotalItems: () =>
        get().items.reduce((sum, item) => sum + (item.quantity || 0), 0),
      getCartTotal: () =>
        get().items.reduce(
          (total, item) => total + (item.price || 0) * (item.quantity || 1),
          0
        ),

      getSelectedTotal: () => {
        const { items, selectedItems } = get();
        const getItemKey = (item) =>
          `${item.id}__${item.sizeOption || "M"}__${JSON.stringify(
            (item.toppings || [])
              .map((t) => (t._id ? t._id.toString() : JSON.stringify(t)))
              .sort()
          )}`;

        return items
          .filter((item) => selectedItems.includes(getItemKey(item)))
          .reduce((sum, item) => sum + item.price * item.quantity, 0);
      },

      mergeDuplicateItems: () => {
        const { items, _mapToppingsForCompare, currentStoreId, storeCarts } =
          get();

        let mergedItems = [];
        for (let i = 0; i < items.length; i++) {
          const current = items[i];
          const existingIndex = mergedItems.findIndex(
            (m) =>
              m.id === current.id &&
              m.sizeOption === current.sizeOption &&
              m.sugarLevel === current.sugarLevel &&
              m.iceOption === current.iceOption &&
              _mapToppingsForCompare(m.toppings) ===
                _mapToppingsForCompare(current.toppings)
          );

          if (existingIndex !== -1) {
            // gi·ªØ nguy√™n ƒë∆°n gi√°, ch·ªâ c·ªông quantity
            mergedItems[existingIndex] = {
              ...mergedItems[existingIndex],
              quantity:
                (mergedItems[existingIndex].quantity || 0) +
                (current.quantity || 0),
            };
          } else {
            mergedItems.push({ ...current });
          }
        }

        // ‚úÖ C·∫¨P NH·∫¨T C·∫¢ storeCarts
        set({
          items: mergedItems,
          storeCarts: {
            ...storeCarts,
            [currentStoreId]: {
              items: mergedItems,
              lastUpdated: Date.now(),
            },
          },
        });
      },

      getItemById: (productId) => {
        const { items } = get();
        return items.find((item) => item.id === productId) || null;
      },

      // ‚úÖ TH√äM: Reload current cart (helper)
      reloadCurrentCart: async () => {
        const { currentStoreId } = get();
        if (!currentStoreId) return;
        await get().loadCartFromBackend(currentStoreId);
      },
    }),
    {
      name: "cart-storage",
      partialize: (state) => ({
        items: state.items,
        selectedItems: state.selectedItems,
        currentStoreId: state.currentStoreId,
        storeCarts: state.storeCarts,
      }),
    }
  )
);

export { useCartStore };
